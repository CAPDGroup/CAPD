//////////////////////////////////////////////////////////////////////////////
//   Package:          CAPD

/////////////////////////////////////////////////////////////////////////////
//
/// @file cosTest.cpp
///
/// @author Daniel Wilczak
//
/////////////////////////////////////////////////////////////////////////////

// Copyright (C) CAPD group
//
// This file constitutes a part of the CAPD library,
// distributed under the terms of the GNU General Public License.
// Consult  http://capd.ii.uj.edu.pl/ for details.

//#define BOOST_TEST_MODULE cosTest
#include "compare.h"
BOOST_AUTO_TEST_SUITE(cosSuite)

std::vector<double> computeCosDer(MapType::VectorType & u){
  double x = u[0].leftBound();
  double y = u[1].leftBound();

  // code generated by the following Mathematica code
  // W[n_,m_]:=D[Cos[x*y+x],{x,n},{y,m}]/(n!m!)//FullSimplify
  // Table[Table[W[m-n,n]//CForm,{n,0,m}],{m,0,5}]//Flatten

  capd::rounding::DoubleRounding::roundNearest();
  double r[] = {Cos(x*(1 + y)),-((1 + y)*Sin(x*(1 + y))),-(x*Sin(x*(1 + y))),-(Power(1 + y,2)*Cos(x*(1 + y)))/2.,-(x*(1 + y)*Cos(x*(1 + y))) - Sin(x*(1 + y)),-(Power(x,2)*Cos(x*(1 + y)))/2.,(Power(1 + y,3)*Sin(x*(1 + y)))/6.,((1 + y)*(-2*Cos(x*(1 + y)) + x*(1 + y)*Sin(x*(1 + y))))/2.,(x*(-2*Cos(x*(1 + y)) + x*(1 + y)*Sin(x*(1 + y))))/2.,(Power(x,3)*Sin(x*(1 + y)))/6.,(Power(1 + y,4)*Cos(x*(1 + y)))/24.,(Power(1 + y,2)*(x*(1 + y)*Cos(x*(1 + y)) + 3*Sin(x*(1 + y))))/6.,((-2 + Power(x,2)*Power(1 + y,2))*Cos(x*(1 + y)) + 4*x*(1 + y)*Sin(x*(1 + y)))/4.,(Power(x,2)*(x*(1 + y)*Cos(x*(1 + y)) + 3*Sin(x*(1 + y))))/6.,(Power(x,4)*Cos(x*(1 + y)))/24.,-(Power(1 + y,5)*Sin(x*(1 + y)))/120.,(Power(1 + y,3)*(4*Cos(x*(1 + y)) - x*(1 + y)*Sin(x*(1 + y))))/24.,((1 + y)*(6*x*(1 + y)*Cos(x*(1 + y)) - (-6 + Power(x,2)*Power(1 + y,2))*Sin(x*(1 + y))))/12.,-(x*(-6*x*(1 + y)*Cos(x*(1 + y)) + (-6 + Power(x,2)*Power(1 + y,2))*Sin(x*(1 + y))))/12.,-(Power(x,3)*(-4*Cos(x*(1 + y)) + x*(1 + y)*Sin(x*(1 + y))))/24.,-(Power(x,5)*Sin(x*(1 + y)))/120.};
  return std::vector<double> (r,r+sizeof(r)/sizeof(double));
}

BOOST_AUTO_TEST_CASE(xcos)
{
  std::string txt = "var:x,y;fun:cos(x*y+x);",
              msg = "Function \"" + txt + "\"  x = " ;
  MapType f(txt,5);
  VectorType x(2);
  x[0] = .5; x[1] = 3.;
  std::vector<double> expected = computeCosDer(x);
  JetType df(1,2,5);
  f(x,df);

  compareResults(expected, df, msg+"(0.5,3.)");

  MapType g("var:x,y;fun:cos(-x*y-x);",5);
  g(x,df);
  compareResults(expected, df, msg+"(0.5,3.)");

  x[0] = -0.75; x[1] = 1.;
  expected = computeCosDer(x);
  f(x,df);
  compareResults(expected, df, msg+"(-0.75,1)");

  x[0] = 0.0; x[1] = 0.0;
  expected = computeCosDer(x);
  f(x,df);
  compareResults(expected, df, msg+"(0.0,0.0)");

}

using capd::autodiff::Node;

void _f(Node /*t*/, Node in[], int /*dimIn*/, Node out[], int /*dimOut*/, Node /*params*/[], int /*noParams*/)
{
  out[0] = cos(-in[0]*in[1]-in[0]);
}

BOOST_AUTO_TEST_CASE(xcosnode)
{
  std::string msg = "Function \"cos(-x*y-x)\"  x = " ;
  MapType f(_f,2,1,0,5);
  VectorType x(2);
  x[0] = .125; x[1]=0.25;
  std::vector<double> expected = computeCosDer(x);
  JetType df(1,2,5);
  f(x,df);
  compareResults(expected, df, msg+"(0.125,0.25)");

  x[0] = -0.75; x[1]=2;
  expected = computeCosDer(x);
  f(x,df);
  compareResults(expected, df, msg+"(-0.75,2.)");

  x[0] = 0.0; x[1] = 0.0;
  expected = computeCosDer(x);
  f(x,df);
  compareResults(expected, df, msg+"(0.0,0.0)");
}

BOOST_AUTO_TEST_SUITE_END()